/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   interface.c                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: eniini <eniini@student.hive.fi>            +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2021/05/18 15:18:00 by eniini            #+#    #+#             */
/*   Updated: 2021/05/21 13:56:19 by eniini           ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

/*
**	UI's background involves shading the pixels generated by the fractal,
**	so draw_bg() funcs happen separately from mlx_string_put calls used to write
**	relevant info into the UI box.
*/

#include "fractol.h"

static void	draw_bg_outline(t_fract *d)
{
	int				i;
	unsigned int	*ptr;

	ptr = (unsigned int *)d->img.addr;
	i = 0;
	while (1)
	{
		if (i >= WIN_H * 0.25 && i >= WIN_W / 3)
			break ;
		if (i < WIN_H * 0.25)
			ptr[i * WIN_W + WIN_W / 3] = 0xFFFFFF;
		if (i < WIN_W / 3)
			ptr[((int)(WIN_H * 0.25 * WIN_W) + WIN_W / 3) - i] = 0xFFFFFF;
		i++;
	}
}

void	draw_ui_bg(t_fract *d)
{
	int				x;
	int				y;
	unsigned int	*ptr;

	ptr = (unsigned int *)d->img.addr;
	y = 0;
	while (y < WIN_H * 0.25)
	{
		x = 0;
		while (x < WIN_W / 3)
		{
			ptr[(y * WIN_W) + x] = ft_color_lerp(ptr[(y * WIN_W) + x], WH, 0.6);
			x++;
		}
		y++;
	}
	draw_bg_outline(d);
}

/*
**	Note: UI text positions should also scale relative to the window size.
*/

static void	draw_ui_multibrot(t_fract *d)
{
	char	*s;

	if (d->shape.multi)
	{
		s = ft_ftoa(d->power, 1);
		if (!s)
			ft_getout(strerror(errno));
		mlx_string_put(d->mlx, d->win, 10, 140, UI, "EXPONENT:");
		mlx_string_put(d->mlx, d->win, 80, 140, UI, s);
		free(s);
	}
}

static void	draw_ui_additional(t_fract *d)
{
	char	**s;

	s = (char **)malloc(sizeof(char *) * 5);
	if (!s)
		ft_getout(strerror(errno));
	s[0] = ft_ftoa(d->x, 6);
	s[1] = ft_ftoa(d->y, 6);
	if (!s[0] || !s[1])
		ft_getout(strerror(errno));
	s[2] = ft_strjoin(s[0], "/");
	s[3] = ft_strjoin(s[2], s[1]);
	if (!s[2] || !s[3])
		ft_getout(strerror(errno));
	s[4] = NULL;
	mlx_string_put(d->mlx, d->win, 10, 100, UI, "MOUSEPOS X/Y:");
	mlx_string_put(d->mlx, d->win, 115, 100, UI, s[3]);
	ft_free_arr(s);
}

void	draw_ui(t_fract *d)
{
	char	**s;

	s = (char **)malloc(sizeof(char *) * 4);
	if (!s)
		ft_getout(strerror(errno));
	s[0] = ft_ftoa(d->scalar, 1);
	if (!s[0])
		ft_getout(strerror(errno));
	s[1] = ft_strjoin(s[0], "x");
	s[2] = ft_ftoa(d->precision, 0);
	if (!s[1] || !s[2])
		ft_getout(strerror(errno));
	s[3] = NULL;
	mlx_string_put(d->mlx, d->win, 10, 20, UI, "SCALE:");
	mlx_string_put(d->mlx, d->win, 60, 20, UI, s[1]);
	mlx_string_put(d->mlx, d->win, 10, 60, UI, "ITERATION COUNT");
	mlx_string_put(d->mlx, d->win, 110, 60, UI, s[2]);
	ft_free_arr(s);
	draw_ui_additional(d);
	draw_ui_multibrot(d);
}
